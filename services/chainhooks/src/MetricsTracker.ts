/**
 * MetricsTracker
 * Tracks users and fees generated by smart contracts
 */

import { UserMetrics, FeeMetrics, ProtocolMetrics, Chain, ChainhookEvent } from '@shared/types';
import { logger } from '@shared/utils/logger';
import { db } from './storage';

export class MetricsTracker {
  private userMetricsCache: Map<string, UserMetrics>;
  private feeMetricsCache: FeeMetrics[];
  private protocolMetrics: ProtocolMetrics;

  constructor() {
    this.userMetricsCache = new Map();
    this.feeMetricsCache = [];
    this.protocolMetrics = this.initializeProtocolMetrics();
  }

  /**
   * Initialize protocol metrics
   */
  private initializeProtocolMetrics(): ProtocolMetrics {
    return {
      totalUsers: 0,
      totalPayments: 0,
      totalVolumeUSD: 0,
      totalFeesCollected: 0,
      averageFeePerPayment: 0,
      paymentsByChain: {} as Record<Chain, number>,
      volumeByChain: {} as Record<Chain, number>,
      lastUpdated: new Date(),
    };
  }

  /**
   * Process payment-intent-created event
   */
  async handlePaymentIntentCreated(event: ChainhookEvent): Promise<void> {
    try {
      const agentAddress = event.agent;
      const sourceChain = event.sourceChain as Chain;

      if (!agentAddress || !sourceChain) {
        logger.warn('Missing agent or sourceChain in payment-intent-created event', { event });
        return;
      }

      // Update or create user metrics
      let userMetrics = this.userMetricsCache.get(agentAddress);

      if (!userMetrics) {
        // New user
        userMetrics = {
          agentAddress,
          totalPayments: 0,
          totalVolumeUSD: 0,
          totalFeesGenerated: 0,
          firstPaymentAt: new Date(),
          lastPaymentAt: new Date(),
          sourceChains: {} as Record<Chain, number>,
          updatedAt: new Date(),
        };
        this.protocolMetrics.totalUsers++;
      }

      // Update payment counts
      userMetrics.totalPayments++;
      userMetrics.sourceChains[sourceChain] = (userMetrics.sourceChains[sourceChain] || 0) + 1;
      userMetrics.lastPaymentAt = new Date();
      userMetrics.updatedAt = new Date();

      this.userMetricsCache.set(agentAddress, userMetrics);

      // Update protocol metrics
      this.protocolMetrics.totalPayments++;
      this.protocolMetrics.paymentsByChain[sourceChain] =
        (this.protocolMetrics.paymentsByChain[sourceChain] || 0) + 1;

      logger.info('Payment intent created - metrics updated', {
        intentId: event.intentId,
        agent: agentAddress,
        chain: sourceChain,
        totalPayments: userMetrics.totalPayments,
      });

      // Persist to database
      await this.saveUserMetrics(agentAddress);
    } catch (error) {
      logger.error('Error handling payment-intent-created event', { error, event });
    }
  }

  /**
   * Process payment-detected event
   */
  async handlePaymentDetected(event: ChainhookEvent): Promise<void> {
    try {
      logger.info('Payment detected', {
        intentId: event.intentId,
        sourceTxHash: event.sourceTxHash,
        detectedAt: event.detectedAt,
      });
    } catch (error) {
      logger.error('Error handling payment-detected event', { error, event });
    }
  }

  /**
   * Process payment-settled event
   */
  async handlePaymentSettled(event: ChainhookEvent): Promise<void> {
    try {
      const agentAddress = event.agent;
      const intentId = event.intentId;
      const usdhAmount = event.usdhAmount ? parseFloat(event.usdhAmount) : 0;
      const netAmount = event.netAmount ? parseFloat(event.netAmount) : 0;
      const feesPaid = event.feesPaid ? parseFloat(event.feesPaid) : 0;
      const sourceChain = event.sourceChain as Chain;

      if (!agentAddress || !intentId) {
        logger.warn('Missing agent or intentId in payment-settled event', { event });
        return;
      }

      // Update user metrics
      const userMetrics = this.userMetricsCache.get(agentAddress);
      if (userMetrics) {
        userMetrics.totalVolumeUSD += netAmount / 1_000_000; // Convert from micro-USDh
        userMetrics.totalFeesGenerated += feesPaid / 1_000_000;
        userMetrics.updatedAt = new Date();
        this.userMetricsCache.set(agentAddress, userMetrics);
      }

      // Create fee metrics record
      const feeMetric: FeeMetrics = {
        intentId,
        agentAddress,
        settlementFee: feesPaid / 1_000_000,
        settlementFeeBps: this.calculateFeeBps(usdhAmount, feesPaid),
        gasSpentUSD: 0, // TODO: Calculate from route execution
        totalFeesUSD: feesPaid / 1_000_000,
        sourceChain,
        sourceAmount: event.sourceAmount || '0',
        usdhAmount: usdhAmount.toString(),
        timestamp: new Date(),
      };

      this.feeMetricsCache.push(feeMetric);

      // Update protocol metrics
      this.protocolMetrics.totalVolumeUSD += netAmount / 1_000_000;
      this.protocolMetrics.totalFeesCollected += feesPaid / 1_000_000;
      this.protocolMetrics.averageFeePerPayment =
        this.protocolMetrics.totalFeesCollected / this.protocolMetrics.totalPayments;
      this.protocolMetrics.volumeByChain[sourceChain] =
        (this.protocolMetrics.volumeByChain[sourceChain] || 0) + (netAmount / 1_000_000);
      this.protocolMetrics.lastUpdated = new Date();

      logger.info('Payment settled - metrics updated', {
        intentId,
        agent: agentAddress,
        netAmount: netAmount / 1_000_000,
        fees: feesPaid / 1_000_000,
        totalVolume: userMetrics?.totalVolumeUSD,
      });

      // Persist to database
      await this.saveUserMetrics(agentAddress);
      await this.saveFeeMetrics(feeMetric);
      await this.saveProtocolMetrics();

    } catch (error) {
      logger.error('Error handling payment-settled event', { error, event });
    }
  }

  /**
   * Process payment-settled-with-withdraw event
   */
  async handlePaymentSettledWithWithdraw(event: ChainhookEvent): Promise<void> {
    // Similar to handlePaymentSettled, but also track withdrawals
    await this.handlePaymentSettled(event);

    logger.info('Payment settled with instant withdrawal', {
      intentId: event.intentId,
      agent: event.agent,
      withdrawn: event.withdrawn,
    });
  }

  /**
   * Calculate fee basis points
   */
  private calculateFeeBps(totalAmount: number, feesAmount: number): number {
    if (totalAmount === 0) return 0;
    return Math.round((feesAmount / totalAmount) * 10000);
  }

  /**
   * Get user metrics
   */
  getUserMetrics(agentAddress: string): UserMetrics | undefined {
    return this.userMetricsCache.get(agentAddress);
  }

  /**
   * Get all user metrics
   */
  getAllUserMetrics(): UserMetrics[] {
    return Array.from(this.userMetricsCache.values());
  }

  /**
   * Get fee metrics for a specific intent
   */
  getFeeMetrics(intentId: string): FeeMetrics | undefined {
    return this.feeMetricsCache.find(fm => fm.intentId === intentId);
  }

  /**
   * Get all fee metrics
   */
  getAllFeeMetrics(): FeeMetrics[] {
    return this.feeMetricsCache;
  }

  /**
   * Get protocol metrics
   */
  getProtocolMetrics(): ProtocolMetrics {
    return this.protocolMetrics;
  }

  /**
   * Save user metrics to database
   */
  private async saveUserMetrics(agentAddress: string): Promise<void> {
    const metrics = this.userMetricsCache.get(agentAddress);
    if (!metrics) return;

    try {
      await db.put(`user_metrics:${agentAddress}`, metrics);
      logger.debug('User metrics saved', { agentAddress });
    } catch (error) {
      logger.error('Failed to save user metrics', { error, agentAddress });
    }
  }

  /**
   * Save fee metrics to database
   */
  private async saveFeeMetrics(feeMetric: FeeMetrics): Promise<void> {
    try {
      await db.put(`fee_metrics:${feeMetric.intentId}`, feeMetric);
      logger.debug('Fee metrics saved', { intentId: feeMetric.intentId });
    } catch (error) {
      logger.error('Failed to save fee metrics', { error, intentId: feeMetric.intentId });
    }
  }

  /**
   * Save protocol metrics to database
   */
  private async saveProtocolMetrics(): Promise<void> {
    try {
      await db.put('protocol_metrics', this.protocolMetrics);
      logger.debug('Protocol metrics saved');
    } catch (error) {
      logger.error('Failed to save protocol metrics', { error });
    }
  }

  /**
   * Load metrics from database on startup
   */
  async loadMetricsFromDatabase(): Promise<void> {
    try {
      // Load protocol metrics
      const protocolMetrics = await db.get('protocol_metrics');
      if (protocolMetrics) {
        this.protocolMetrics = protocolMetrics;
      }

      // Load user metrics (this is a simplified version - in production,
      // you'd want to use a proper database query)
      logger.info('Metrics loaded from database', {
        totalUsers: this.protocolMetrics.totalUsers,
        totalPayments: this.protocolMetrics.totalPayments,
        totalVolumeUSD: this.protocolMetrics.totalVolumeUSD,
      });
    } catch (error) {
      logger.error('Failed to load metrics from database', { error });
    }
  }
}
